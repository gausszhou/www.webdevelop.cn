(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{529:function(_,v,t){"use strict";t.r(v);var a=t(10),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"计算机编程语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算机编程语言"}},[_._v("#")]),_._v(" 计算机编程语言")]),_._v(" "),t("h2",{attrs:{id:"_10-早期的编程方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-早期的编程方式"}},[_._v("#")]),_._v(" 10.早期的编程方式")]),_._v(" "),t("ol",[t("li",[_._v("给机器编程的需求早在计算机出现之前就有了。")]),_._v(" "),t("li",[_._v("早期给计算机编程的方式是打孔纸带，想要修改程序的时候就用胶带将需要封住的孔给封住。")]),_._v(" "),t("li",[_._v("计算机大神——冯·诺依曼，提出了冯诺依曼架构，又称普林斯顿架构，这是现在通用计算机的主流架构，此外还有哈弗大学的哈弗架构。")]),_._v(" "),t("li",[_._v("现代化的一些 CPU 综合了冯式架构和哈弗架构，在内部利用冯式结构数据线地址线复用的特点，提高资源的体用效率，在外部使用哈弗结构，数据和逻辑运算分开，方便简单指令集的的实现，为高级语言的设计带来方便。")]),_._v(" "),t("li",[_._v("第一款取得商业成功的家用计算机：Altair 8800，这是一个组装电脑的套件，很多计算机大神的早期经历都和这台计算机有关，比如乔布斯就是靠它发家的。")]),_._v(" "),t("li",[_._v("虽然这时的计算机可以进行编程了，但是使用晦涩的汇编语言进行编程依然很困难，人们需要更加友好简单的方式来进行编程。")])]),_._v(" "),t("h2",{attrs:{id:"_11-编程语言发展史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-编程语言发展史"}},[_._v("#")]),_._v(" 11.编程语言发展史")]),_._v(" "),t("ol",[t("li",[_._v("最开始编程，直接使用的二进制，现在纸上写伪代码，然后手工转换成二进制的机器码")]),_._v(" "),t("li",[_._v("后来有了助记符，用助记符来写代码，然后通过汇编器来把助记符转换成二进制的机器码，这就是汇编语言")]),_._v(" "),t("li",[_._v("Grace 是哈弗 1 号计算机的首批程序员，海军军官，TA 设计了编程语言 A-0，同期还有 FORTRAN 语言，这些都不是通用编程语言。")]),_._v(" "),t("li",[_._v("后来慢慢的出现了通用编程语言，通用编程语言的口号是，一次编写到处运行，初期代表有 ALGOL, LISP, BASIC, Pascal, C, Smalltalk")]),_._v(" "),t("li",[_._v("再后来就是 C++, Objective-C, Perl, Python, Ruby, Java.....这些编程语言除了汇编以外都称为高级语言，大多数高级语言都是通过编译器转换成汇编语言，再通过汇编器将汇编代码转换成机器码。")])]),_._v(" "),t("h2",{attrs:{id:"_12-编程基础-语句和函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-编程基础-语句和函数"}},[_._v("#")]),_._v(" 12.编程基础-语句和函数")]),_._v(" "),t("ol",[t("li",[_._v("作为一门编程语言的基本共同点有：变量，赋值，条件判断，循环以及函数等。")]),_._v(" "),t("li",[_._v("函数-方法-子程序，这几个概念是相近的，将一系列的函数写成单独的文件，称为函数的封装，利用引入，导入，连接等方法可以调用这些封装的函数，功能完备且受人认可的封装，称之为库，利用库我们能更快速的实现想要的功能。")])]),_._v(" "),t("h2",{attrs:{id:"_13-算法入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-算法入门"}},[_._v("#")]),_._v(" 13.算法入门")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("程序是用来解决实际问题的，解决问题的方法有很多，但有的方法效率高，有的方法效率低，为了衡量程序的效率，我们对程序的效率从空间和时间两个方方面进行考量，这就是程序算法的空间复杂度和时间复杂度。")])]),_._v(" "),t("li",[t("p",[_._v("对算法复杂度的考量不需要过于精确，在数学上我们用大 O 表示法，来表示算法复杂度的数量级。")])]),_._v(" "),t("li",[t("p",[_._v("最经典的问题是对数组元素的排序，典型的排序算法有，冒泡排序，选择排序，快速排序和归并排序，这四种排序算法是任何计算机从业者都需要掌握的最基本排序算法。")])]),_._v(" "),t("li",[t("p",[_._v("为了应对不同的实际问题，人们需要设计了不同的数据结构，来高效的表示需要处理的数据，其中最典型的数据结构有，链表，堆栈，队列，二叉树，以及图、")])]),_._v(" "),t("li",[t("p",[_._v("迪杰斯特拉算法是荷兰科学家迪杰斯特拉在 1959 年提出的，是从一个顶点到其余各顶点的最短路径算法。核心思路是采用贪心的策略，每次遍历到起始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。这个算法可以类比成排序中的冒泡算法，是图算法的入门经典。")])])]),_._v(" "),t("h2",{attrs:{id:"_14-数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-数据结构"}},[_._v("#")]),_._v(" 14.数据结构")]),_._v(" "),t("ol",[t("li",[_._v("数组 Array 字符串 String 矩阵 Matrix 结构体 Struct 指针 Pointer")]),_._v(" "),t("li",[_._v("节点 Node 链表 Linked List 队列 Queue 栈 Stack 堆 Heap 树 Tree 二叉树 Binary Tree 图 Graph 红黑树 Red-Black-Tree")])]),_._v(" "),t("h2",{attrs:{id:"_15-阿兰·图灵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-阿兰·图灵"}},[_._v("#")]),_._v(" 15.阿兰·图灵")]),_._v(" "),t("ol",[t("li",[_._v("阿兰·图灵，计算机科学之父，人工会智能之父，提出了图灵机的概念，揭示了计算机的运行原理，为现代计算机的逻辑工作方式奠定了基础。")]),_._v(" "),t("li",[_._v("图灵测试，图灵提出的一种用于判断机器是否具有智能的实验方法，也是对智能这一概念的操作性定义。PS：至今人们都未能给出关于智能这一概念准确的描述性定义。")]),_._v(" "),t("li",[_._v("图灵奖，一年一评，是计算机界最负盛名，最崇高的一个奖项。")]),_._v(" "),t("li",[_._v("停机问题，是逻辑数学中可计算性理论的一个问题，判断一个程序是否能在有限时间内结束的问题，本质上是一个高阶逻辑的不自洽性和不完备性，因此不存在能解决停机问题的方法。")]),_._v(" "),t("li",[_._v("哥德尔不完备性第一定理，任何一个包含一阶逻辑和初等数论的形式系统，都至少存在一个命题，TA 在这个系统中既不能证明，也不能证伪。PS：这似乎就是不可知论的一个强有力的论据")])]),_._v(" "),t("h2",{attrs:{id:"_16-软件工程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-软件工程"}},[_._v("#")]),_._v(" 16.软件工程")]),_._v(" "),t("ol",[t("li",[_._v("软件工程讲的是一个关于合作开发软件的故事，软件工程这门新科学，解决的是大型软件中各个部门各个员工协同合作中产生的问题。")]),_._v(" "),t("li",[_._v("关于软件工程需要了解的概念属于有：\n"),t("ol",[t("li",[_._v("面对对象编程 OOP Object Oriented Programing")]),_._v(" "),t("li",[_._v("应用程序接口 API Application Programing Interface")]),_._v(" "),t("li",[_._v("继承开发环境 IDE Integrated Development Environments")]),_._v(" "),t("li",[_._v("调试 debugging 文档 readme 注释 comment")]),_._v(" "),t("li",[_._v("代码复用性 code reuse 版本控制 version contral 代码仓库 code repository")]),_._v(" "),t("li",[_._v("质量保证测试 Quality Assurance Testing 内部版本 alpha 测试版本 beta")])])])]),_._v(" "),t("h2",{attrs:{id:"_17-集成电路与摩尔定律"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-集成电路与摩尔定律"}},[_._v("#")]),_._v(" 17.集成电路与摩尔定律")]),_._v(" "),t("ol",[t("li",[_._v("集成电路，采用一定工艺把一个电路中所需的分立元件及布线连在一起，制成一小块半导体晶片，然后封装，称为具有一定功能的单独的微型结构。")]),_._v(" "),t("li",[_._v("数字暴政，1960 年代计算机工程师遇到的问题，意思是如果想加强电脑性能，就需要更多的部件，更多的线路，这会让电路变得更加复杂，很难处理")]),_._v(" "),t("li",[_._v("摩尔定律，英特尔创始人之一 Gordon Moore 提出的，当价格不变时，集成电路可容纳的元器件的数目，每个 18-24 个月就会翻一倍")]),_._v(" "),t("li",[_._v("摩尔定律遇到瓶颈，电路小型化到一定程度，就会遇到一个严重的瓶颈，目前这个瓶颈的主要因素有：\n"),t("ol",[t("li",[_._v("光刻机产生的光不足以制作更精细的设计，需要能够产生更短波长光的技术，比如极紫外光刻")]),_._v(" "),t("li",[_._v("尺寸达到微观领域，电子会发生量子隧穿效应，导致逻辑错误")])])])])])}),[],!1,null,null,null);v.default=r.exports}}]);