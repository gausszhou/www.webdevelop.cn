(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{573:function(t,a,_){"use strict";_.r(a);var v=_(10),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"第2章-寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第2章-寄存器"}},[t._v("#")]),t._v(" 第2章 寄存器")]),t._v(" "),_("p",[t._v("​\t一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于CPU内部来说是外部总线。内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。")]),t._v(" "),_("p",[t._v("​\t对一个汇编程序员来说，CPU的主要器件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制。")]),t._v(" "),_("h3",{attrs:{id:"_2-1-通用寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-通用寄存器"}},[t._v("#")]),t._v(" 2.1 通用寄存器")]),t._v(" "),_("p",[t._v("​\t8086CPU的所有寄存器都是16位的，可以存放两个字节。AX/BX/CX/DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器。为了保证兼容，8086CPU上的这4个通用寄存器都可分为两个独立使用的8位寄存器来用。")]),t._v(" "),_("h3",{attrs:{id:"_2-2-字在寄存器中的存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-字在寄存器中的存储"}},[t._v("#")]),t._v(" 2.2 字在寄存器中的存储")]),t._v(" "),_("p",[t._v("​\t一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在寄存器的高8位寄存器和低8位寄存器中。")]),t._v(" "),_("p",[t._v("​\t任何数据，到了计算机中都是以二进制的形式存放的。为了描述不同的问题，又经常将它们用其他的进制来表示。十六进制数的一位相当于二进制数的四位。")]),t._v(" "),_("h3",{attrs:{id:"_2-3-几条汇编指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-几条汇编指令"}},[t._v("#")]),t._v(" 2.3 几条汇编指令")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("汇编指令")]),t._v(" "),_("th",[t._v("控制CPU完成的操作")]),t._v(" "),_("th",[t._v("高级语言描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("mov ax, 18")]),t._v(" "),_("td",[t._v("将18送入寄存器AX")]),t._v(" "),_("td",[t._v("AX=18")])]),t._v(" "),_("tr",[_("td",[t._v("mov ah,78")]),t._v(" "),_("td",[t._v("将78送入AH")]),t._v(" "),_("td",[t._v("AH=78")])]),t._v(" "),_("tr",[_("td",[t._v("add ax, 8")]),t._v(" "),_("td",[t._v("将寄存器AX中的数值加上18")]),t._v(" "),_("td",[t._v("AX=AX+8")])]),t._v(" "),_("tr",[_("td",[t._v("mov ax, bx")]),t._v(" "),_("td",[t._v("将寄存器BX中的数据送入寄存器AX")]),t._v(" "),_("td",[t._v("AX=BX")])]),t._v(" "),_("tr",[_("td",[t._v("add ax, bx")]),t._v(" "),_("td",[t._v("将AX和BX中的数值相加，结果存在AX中")]),t._v(" "),_("td",[t._v("AX=AX+BX")])])])]),t._v(" "),_("h3",{attrs:{id:"检测点2-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#检测点2-1"}},[t._v("#")]),t._v(" 检测点2.1")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("写出每条汇编指令执行后相关寄存器中的值")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("mov ax, 62627 \tAX = F4A3H\nmov ah, 31h  \tAX = 31A3H\nmov al, 23h\t\tAX = 3123H\nadd ax, ax\t\tAX = 6246H\nmov bx, 826ch\tBX = 826CH\nmov cx, ax\t\tCX = 6246H\nmov ax, bx\t\tAX = 826CH\nadd ax, bx \t\tAX = 04D8H\nmov al, bh \t\tAX = 0482H\nmov ah, bl\t\tAX = 6C82H\nadd ah, ah \t\tAX = D882H\nadd al, 6\t\tAX = D888H\nadd al, al\t\tAX = D810H\nmov ax ,cx\t\tAX = 3A56H\n")])])])]),t._v(" "),_("li",[_("p",[t._v("只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("mov al, 2\t\tAX = 0002H \nadd al, al\t\tAX = 0004H\nadd al, al\t\tAX = 0008H\nadd al, al\t\tAX = 0010H\n")])])])])]),t._v(" "),_("h3",{attrs:{id:"_2-4-物理地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-物理地址"}},[t._v("#")]),t._v(" 2.4 物理地址")]),t._v(" "),_("p",[t._v("​\t我们知道，CPU访问内存单元是，要给出内存单元的地址。所有内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中具有唯一的地址，我们将这个唯一的地址称为物理地址。")]),t._v(" "),_("h3",{attrs:{id:"_2-5-16位结构的cpu"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-16位结构的cpu"}},[t._v("#")]),t._v(" 2.5 16位结构的CPU")]),t._v(" "),_("p",[t._v("​\t8086是16位结构的CPU，这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度为16位。")]),t._v(" "),_("h3",{attrs:{id:"_2-6-8086-cpu给出物理地址的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-8086-cpu给出物理地址的方法"}},[t._v("#")]),t._v(" 2.6 8086 CPU给出物理地址的方法")]),t._v(" "),_("p",[t._v("​\t8086CPU有20位地址总线，可以传送20位地址，达到1M寻址能力。但是8086是16位结构，如果将地址地从内部简单的发出，那么它只能送出16位的地址，表现出的寻址能力只有64K。")]),t._v(" "),_("p",[t._v("​\t8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。")]),t._v(" "),_("p",[t._v("​\t地址加法器采用物理地址=段地址乘16+偏移地址的方法用段地址和偏移地址合成物理地址。")]),t._v(" "),_("h3",{attrs:{id:"_2-7-段地址乘16-偏移地址-物理地址-的本质含义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-段地址乘16-偏移地址-物理地址-的本质含义"}},[t._v("#")]),t._v(" 2.7 ”段地址乘16 + 偏移地址=物理地址“的本质含义")]),t._v(" "),_("p",[t._v("​\t ”段地址乘16 + 偏移地址=物理地址“的本质含义是：CPU在访问内存时，用一个基础地址（段地址X16）和一个现对于基础地址的偏移地址相加，给出内存单元的物理地址。8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”的一种具体实现方案。")]),t._v(" "),_("h3",{attrs:{id:"_2-8-段的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-段的概念"}},[t._v("#")]),t._v(" 2.8 段的概念")]),t._v(" "),_("p",[t._v("​\t在编程时可以根据需要，将若干地址连续的内存单元看做一个端，用段地址X16定位短的基础地址，用偏移地址定位段中的内存单元")]),t._v(" "),_("h3",{attrs:{id:"_2-9-段寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-段寄存器"}},[t._v("#")]),t._v(" 2.9 段寄存器")]),t._v(" "),_("h3",{attrs:{id:"_2-10-cs和ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-cs和ip"}},[t._v("#")]),t._v(" 2.10 CS和IP")]),t._v(" "),_("h3",{attrs:{id:"_2-11-修改cs、ip的指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-11-修改cs、ip的指令"}},[t._v("#")]),t._v(" 2.11 修改CS、IP的指令")]),t._v(" "),_("h3",{attrs:{id:"_2-12-代码段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-12-代码段"}},[t._v("#")]),t._v(" 2.12 代码段")])])}),[],!1,null,null,null);a.default=s.exports}}]);